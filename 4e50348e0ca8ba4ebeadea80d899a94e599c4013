{
  "comments": [
    {
      "key": {
        "uuid": "8ed34346_97a39f3f",
        "filename": "lib/includes/Store/DispatchingPropertyInfoLookup.php",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 4089
      },
      "writtenOn": "2016-12-06T16:46:41Z",
      "side": 1,
      "message": "This case is not covered by tests. \nCondition can be replaced with `true` and all tests still pass.",
      "range": {
        "startLine": 40,
        "startChar": 73,
        "endLine": 40,
        "endChar": 77
      },
      "revId": "4e50348e0ca8ba4ebeadea80d899a94e599c4013",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8ed34346_d7c3573c",
        "filename": "lib/tests/phpunit/Store/DispatchingPropertyInfoLookupTest.php",
        "patchSetId": 3
      },
      "lineNbr": 37,
      "author": {
        "id": 4089
      },
      "writtenOn": "2016-12-06T16:46:41Z",
      "side": 1,
      "message": "There is a `setUp()` method in phpunit which will be called before each test so you don\u0027t need to play with test case\u0027s constructor.\nIt may become a problem when we decide to upgrade PhpUnit version and constructor arguments in PHPUnit_Framework_TestCase are changed.\n\nSee https://phpunit.de/manual/current/en/fixtures.html",
      "range": {
        "startLine": 25,
        "startChar": 1,
        "endLine": 37,
        "endChar": 2
      },
      "revId": "4e50348e0ca8ba4ebeadea80d899a94e599c4013",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8ed34346_8e4dc19d",
        "filename": "lib/tests/phpunit/Store/DispatchingPropertyInfoLookupTest.php",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 4089
      },
      "writtenOn": "2016-12-07T10:33:18Z",
      "side": 1,
      "message": "It seems like logic duplication, because inner PropertyInfoLookup already knows what namespace it is in - it returns properties ids like `foo:P42`. \nThen if we duplicate this data in keys it probably will bring confusion and also might become source of errors.\n \n I see two approaches that make sense for me:\n   1 We set namespaces in keys and inner PropertyInfoLookups are  getting called with PropertyIds which don\u0027t contain an namespace info and return data is also namespace agnostic, only DispatchingPropertyInfoLookup knows about namespaces and adds them where necessary.\n   2. DispatchingPropertyInfoLookup receives nonassoc (regular) array in constructor and then asks each of inner PropertyInfoLookups which namespace they have so it can ask only one of them. Inner PropertyInfoLookup is called with PropertyId containing namespace so it also can check that it is right and throw an exception if it is not.",
      "range": {
        "startLine": 42,
        "startChar": 3,
        "endLine": 42,
        "endChar": 8
      },
      "revId": "4e50348e0ca8ba4ebeadea80d899a94e599c4013",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8ed34346_fc650fab",
        "filename": "lib/tests/phpunit/Store/DispatchingPropertyInfoLookupTest.php",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 2626
      },
      "writtenOn": "2016-12-07T14:22:38Z",
      "side": 1,
      "message": "Thanks for making this comment. You\u0027ve raised a very valid points here.\n\nWe should document the idea behind \"dispatching services\" (as the DispatchingPropertyInfoLookup here) better somewhere, so it is more clear.\n\n1. We have decided that dispatching should not be responsible for adding/removing repository prefixes (like foo in foo:P42). Stripping a prefix before querying a database, and adding a right prefix to the resulting entity id etc, should be done in the service actually touching the database, and creating the resulting entity id.\nYou\u0027re right in saying that the \"inner\" service will often know which repository it is configured to be used with (like \"foo\" in the example). Among other reasons we want the service accessing the database of repository \"foo\" to make sure it is asked for entities belonging to this repository. Otherwise unpredicted things could happen.\n\n2. In case of this service it seems that requiring dispatching service to receive a repo name \u003d\u003e repo-specific service map instead of simple list of services is a bit redundant. We could have a method like isLookupFor( EntityId $id ) or isLookupForRepository( $repoName ) in repo-specific PropertyInfoLookups, and have DispatchingLookup simply enumerate the list of lookups and pick the right one using this method, not based on the repo name string.\nI believe this new method should not be the part of PropertyInfoLookup interface, we\u0027d rather like to have something like DispatchablePropertyInfoLookup interface providing such method (cf. DispatchableSerializer/DispatchableDeserializer in DataModel component).\nHaving vary briefly thought about it I think this could work, and might be a bit cleaner than the approach we\u0027ve been using in dispatching services so far.\n\nWhat I am still not sure about though is that in case of many services there is a full bunch of wrapping services we use. For instance, given we had two repos \"wd\" and \"foo\", and have a PropertyInfoTable wrapped in CachingPropertyInfoStore. To use those in DispatchingPropertyInfoLookup we would need CachingPropertyInfoStore to also implement DispatchableInfoLookup. I am not sure if this makes sense (maybe...) and are there further implications. Situation could be even more complex in case of other service (one more level of wrapping in case of EntityRevisionLookup, for example).\n\n\nI think we should continue this discussion somewhere else as any change in the general dispatching service scenario should not only be reflected in this patch.",
      "parentUuid": "8ed34346_8e4dc19d",
      "range": {
        "startLine": 42,
        "startChar": 3,
        "endLine": 42,
        "endChar": 8
      },
      "revId": "4e50348e0ca8ba4ebeadea80d899a94e599c4013",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8ed34346_b7857ba1",
        "filename": "lib/tests/phpunit/Store/DispatchingPropertyInfoLookupTest.php",
        "patchSetId": 3
      },
      "lineNbr": 83,
      "author": {
        "id": 4089
      },
      "writtenOn": "2016-12-06T16:46:41Z",
      "side": 1,
      "message": "Private method is before public (test). \nUsually private methods go to the bottom of the class. Do we have this convention?",
      "range": {
        "startLine": 83,
        "startChar": 1,
        "endLine": 83,
        "endChar": 50
      },
      "revId": "4e50348e0ca8ba4ebeadea80d899a94e599c4013",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8ed34346_97783fef",
        "filename": "lib/tests/phpunit/Store/DispatchingPropertyInfoLookupTest.php",
        "patchSetId": 3
      },
      "lineNbr": 84,
      "author": {
        "id": 4089
      },
      "writtenOn": "2016-12-06T16:46:41Z",
      "side": 1,
      "message": "I\u0027m not sure, but there is class \\Wikibase\\Lib\\Tests\\Store\\MockPropertyInfoStore which seem to do basically the same thing as current mock. Shouldn\u0027t we use the class?",
      "range": {
        "startLine": 84,
        "startChar": 2,
        "endLine": 84,
        "endChar": 56
      },
      "revId": "4e50348e0ca8ba4ebeadea80d899a94e599c4013",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    }
  ]
}