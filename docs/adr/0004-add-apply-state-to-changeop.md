# 4. Add apply() result state to ChangeOp

Date: 2019-06-21

## Status

Proposed

## Context

`wbeditentity` summary message for Wikibase Items and Properties provides
very little information on what have been changed on the entity, with the main
message in the summary being "Item Changed".

In T220696[1], we want to update those summary
messages generated for Wikibase Items and Properties when using `wbeditentity`
to be more detailed and informative.

Wikibase Lexeme achieved generating detailed summary messages by:

1. making its ChangeOp implementations update the summary object passed to
   the change op instance with granular information about the change.

2. implementing Wikibase\Lexeme\MediaWiki\Api\Summary\SummaryAggregator class
   and using it internally in some ChangeOp implementations (some of those that
   are non-leaf nodes and contain further change ops) in order to combine those
   summary messages generated by leaf nodes (the effective change ops in the
   tree).

## Considered actions

### I. Reusing current pattern

We considered doing the same thing for Wikibase, but that seemed a little off
with regards to clean design.

The main two places where this off-feeling came from are:

1. a tree hierarchy is often implemented for structural purposes, and then
   accessed through visitors for logic (implementing the Visitor pattern[2].

2. currently ChangeOp is concerned with:

	a. representing a change that can be applied to an entity

	b. applying that change to an entity

	c. generating summary messages as a result of applying it to an entity

### II. Visitor pattern design

We then considered:

1. using Visitor Pattern[2] to implement our detailed summary generation
   for Wikibase Items and Properties;

2. changing ChangeOp design in a way that:

	a. allows a visitor class to operate over change ops hierarchy and attain
		the information it needs from it to complete its job. These information
		include whether the change op has been applied or discarded (no-op).

	b. is not a breaking change (WikibaseLexeme should continue to operate with
		no touch to it).

	c. does not extract the logic of applying a change op to an entity outside
		of it (remember logic can be implemented as a visitor) as it is out
		of scope and it isn't clear whether it will have enough justification.

This solution comes with some cost of initial implementation and
refactoring of current ChangeOp design and relevant implementations within
Wikibase and WikibaseLexeme.

The benefits of this solution is that it:

1. uses a more standard pattern with tree structures.

2. extracts the concern of summary messages generation out of
   ChangeOp, simplifying its design and implementations and scoping down
   the domain and dependencies of ChangeOp.


## Decision

We decided to go with the second option, the visitor pattern design.

**Once we decide, we keep only one of the two variants below in this ADR**

The very next step to this ADR, once approved, is one of the two variants:

a) making ChangeOp stateful:

	- add Status concept to ChangeOp interface and design.
	this can be simply achieved for now via accessor methods and constants
	for the different statuses that a change op can be at.

	the statuses that a change op will need to support by this decision,
	and for the sake of the requirments at hand, are along those lines:
		- initial state: change op hasn't been applied yet.
		- document changed: change op was applied and did change the document
		- document not changed: change op was applied but did not change
		the document

b) keeping ChangeOp stateless:

	this variation is the same as above with one twist. Instead of adding
	status concept directy to the current ChangeOp interface, an new
	interface is created to represent the result of applying a change op
	tree on a document.

	For example, we can add a new interface called ChangeOpResult, that
	will be a mirror to the change ops tree but to represent the result
	of applying each chage op in that tree.

	A visitor then operates on a ChangeOpResult tree structure instead.


## Consequences

The potential consequences of going with visitor pattern design are:

1. **only for variant A** [permanent] ChangeOp will become a stateful construct,
   compared to the previous design.

2. [short-term] Wikibase and WikibaseLexeme will have two separate ways to
   achieve similar requirements.

   This can be mitigated by a follow-up refactoring task that changes
   Lexeme implementation into reusing the visitor pattern.


## Notes

Changing ChangeOp interface in Wikibase will result in failing CI jobs
due to the fact that Wikbiase CI will also run WikibaseLexeme tests
as part of its pipeline. This creates a circular situation for implementations
of ChangeOp interface.

The way to go around it is to go in this order:

1. implement the new to-be-added methods to ChangeOp interface in WikibaseLexeme
   implementations of that interface (can be empty atm).

2. add the new methods to ChangeOp interface in Wikibase, and make that change
   depend on the change from 1 above. Implementations of ChangeOp in Wikibase
   itself can be updated with the new methods in this step or a separate follow
   up step.

Although this situation is not good enough as a reason, but it slightly hints
that ChangeOp concepts might better be moved out into a separate library that
can then be versioned and depended on as per usual proper mechanisms.

----

[1] https://phabricator.wikimedia.org/T220696

[2] Visitor Pattern https://en.wikipedia.org/wiki/Visitor_pattern
