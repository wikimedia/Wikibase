{
  "comments": [
    {
      "key": {
        "uuid": "ee14bf34_50debf71",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1453
      },
      "writtenOn": "2014-03-18T11:49:49Z",
      "side": 1,
      "message": "I\u0027m very sorry, but this is just lazy. I know it works (there can not be a second 4 digit number in a parsed date) but it still is a lazy hack. Such may be done in a test but shouldn\u0027t in production code.",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_922a09d6",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 106
      },
      "writtenOn": "2014-03-20T17:04:57Z",
      "side": 1,
      "message": "As far as I am aware there would be no other way to use the DateTime object...\nA year has to be passed in.\nIf we cant pass in a 5 digit+ year then we must pass in a dummy year that we can change later.\nThis is the same as is currently done in the time formatters where again a 5+ digit year can not be used.",
      "parentUuid": "ee14bf34_50debf71",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_c887aedb",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1453
      },
      "writtenOn": "2014-03-20T21:05:02Z",
      "side": 1,
      "message": "As said in an other comment I would prefer a solution that uses the last 4 digits from the actual year. This should make sure the leap year problem does have the best chance to \"survive\".\n\nTest cases to add:\n* \u002710000-02-29\u0027 \u003d\u003e valid\n* \u002710100-02-29\u0027 \u003d\u003e invalid or March 1\n* \u002710400-02-29\u0027 \u003d\u003e valid",
      "parentUuid": "ee14bf34_922a09d6",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_dc2f8b9b",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 128
      },
      "writtenOn": "2014-03-18T10:50:08Z",
      "side": 1,
      "message": "Please document what format is expected.\nAlso, \"and returns the result\" is a bit redundant :)",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_7227750e",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 106
      },
      "writtenOn": "2014-03-20T17:04:57Z",
      "side": 1,
      "message": "Done in next PS",
      "parentUuid": "ee14bf34_dc2f8b9b",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_1c0d0342",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 76,
      "author": {
        "id": 128
      },
      "writtenOn": "2014-03-18T10:50:08Z",
      "side": 1,
      "message": "Can\u0027t we just extract the year and convert it to int an, replace it by \"2000\" in the date string, and then parse? Less special cases, less confusion...",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_10bf27f8",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 76,
      "author": {
        "id": 1453
      },
      "writtenOn": "2014-03-18T11:49:49Z",
      "side": 1,
      "message": "What\u0027s with leap years? What if you replace \"29 February 202020\" with \"29 February 4242\" or \"29 February 2000\"? How do you know the day does have the same meaning in the original and the shorter placeholder year?",
      "parentUuid": "ee14bf34_1c0d0342",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_52247107",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 76,
      "author": {
        "id": 106
      },
      "writtenOn": "2014-03-20T17:04:57Z",
      "side": 1,
      "message": "Daniel, I am confused by your comment, thats is basically what we are doing.\nWe are taking the year our and putting in a placeholder year, though instead of 2000 I am using 4242. Then we parse it and put the original year back.\n\nLeap years are indeed a special case that I have not thought about.\nAs 4242 is apparently not a leap year all 29ths of Feb for years with more than 5 digits would be parsed as the 1st of March instead.",
      "parentUuid": "ee14bf34_10bf27f8",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_d0dc0f4e",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 77,
      "author": {
        "id": 1453
      },
      "writtenOn": "2014-03-18T11:49:49Z",
      "side": 1,
      "message": "To complicated. \u0027/\\d{5,}/\u0027 and $matches[0] is enough to do the same.\n\nBut, please consider an other solution. I remember a similar solution in an other class. It stripped the first digits from 5+ digit years, parsed the remaining 4 digit year and put the additional digits back. Why not do the same?\n\npreg_match( \u0027/(\\d+)\\d{4}/\u0027, ..., PREG_OFFSET_CAPTURE )\n$prefix \u003d $matches[0][0];\n$offset \u003d $matches[0][1];\n$value \u003d substr( ..., 0, $offset ) . substr( ..., $offset + strlen( $prefix ) )\n$timeString \u003d \u0027+\u0027 . $prefix . $dateTime-\u003eformat( ... );\n\nAdd tests for stuff like \"1 May 10999\" and make sure it does not become \"1999-05-01\".",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_3221fdf6",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 77,
      "author": {
        "id": 106
      },
      "writtenOn": "2014-03-20T17:04:57Z",
      "side": 1,
      "message": "Indeed that is what happens in the formatting class currently.\nWe would have exactly the same problem parsing in this way as you have mentioned above with leap years.",
      "parentUuid": "ee14bf34_d0dc0f4e",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_b054fbca",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 88,
      "author": {
        "id": 1453
      },
      "writtenOn": "2014-03-18T11:49:49Z",
      "side": 1,
      "message": "str_replace is enough.\n\nAlso, you do not have the guarantee that your placeholder number still is in the string and still looks exactly the same. You don\u0027t really know what DateTime does.",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_127ef9e1",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 88,
      "author": {
        "id": 106
      },
      "writtenOn": "2014-03-20T17:04:57Z",
      "side": 1,
      "message": "DateTime will give me the year as I ask for it in the fromat...\n\u0027Y-m-d\\TH:i:s\\Z\u0027\nthus the year will always be there as exactly \u00274242\u0027\nstr_replace does not have a $limit parameter so I would prefer to use preg_replace here\nI guess another options would be to simply remove the first 4 characters and replace them with our year, that would certainly save a few micro server kittens",
      "parentUuid": "ee14bf34_b054fbca",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee14bf34_8843f6b5",
        "filename": "lib/includes/parsers/DateTimeParser.php",
        "patchSetId": 4
      },
      "lineNbr": 88,
      "author": {
        "id": 1453
      },
      "writtenOn": "2014-03-20T21:05:02Z",
      "side": 1,
      "message": "I guess it\u0027s the replace - no matter which - that bugs me. Why put the dummy in the string just to replace it?\n\nif ( $largeYear ) {\n\t$timeString \u003d $largeYear . $dateTime-\u003eformat( \u0027-m-d\\TH:i:s\\Z\u0027 );\n} else {\n\t$timeString \u003d $dateTime-\u003eformat( \u0027Y-m-d\\TH:i:s\\Z\u0027 );\n}\n$timeString \u003d \u0027+\u0027 . $timeString;",
      "parentUuid": "ee14bf34_127ef9e1",
      "revId": "f0168efeb0da78e1df63f58dbe2d36d837143f24",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    }
  ]
}