<?php

namespace Wikibase\Lib\Tests\Changes;

use Diff\DiffOp\Diff\Diff;
use Diff\DiffOp\DiffOpChange;
use Exception;
use Wikibase\DataModel\Services\Diff\ItemDiff;
use Wikibase\EntityChange;
use Wikibase\ItemChange;
use Wikibase\Lib\Changes\EntityDiffChangedAspectsFactory;

/**
 * @covers Wikibase\ItemChange
 * @covers Wikibase\DiffChange
 *
 * @group Database
 * @group Wikibase
 * @group WikibaseChange
 *
 * @license GPL-2.0+
 * @author Daniel Kinzler
 */
class ItemChangeTest extends EntityChangeTest {

	/**
	 * @return string
	 */
	protected function getRowClass() {
		return ItemChange::class;
	}

	public function itemChangeProvider() {
		$changes = array_filter(
			TestChanges::getChanges(),
			function( EntityChange $change ) {
				return ( $change instanceof ItemChange );
			}
		);

		$cases = array_map( function( ItemChange $change ) {
			return [ $change ];
		},
		$changes );

		return $cases;
	}

	/**
	 * @dataProvider changeProvider
	 *
	 * @param ItemChange $change
	 */
	public function testGetSiteLinkDiff( ItemChange $change ) {
		$siteLinkDiff = $change->getSiteLinkDiff();
		$this->assertInstanceOf( Diff::class, $siteLinkDiff, 'getSiteLinkDiff must return a Diff' );
	}

	/**
	 * @dataProvider changeProvider
	 *
	 * @param ItemChange $change
	 */
	public function testGetSiteLinkDiffFromCompactDiff( ItemChange $change ) {
		$info = $change->getInfo();
		if ( !array_key_exists( 'compactDiff', $info ) ) {
			$aspects = ( new EntityDiffChangedAspectsFactory() )->newFromEntityDiff(
				$change->getDiff()
			);
			$info['compactDiff'] = $aspects;
			$change->setField( 'info', $info );
		}
		$siteLinkDiff = $change->getSiteLinkDiff();
		$this->assertInstanceOf( Diff::class, $siteLinkDiff, 'getSiteLinkDiff must return a Diff' );
	}

	public function changeBackwardsCompatProvider() {
		global $wgDevelopmentWarnings;

		//NOTE: Disable developer warnings that may get triggered by
		//      the B/C code path.
		$wgDevelopmentWarnings = false;
		\MediaWiki\suppressWarnings();

		try {
			$cases = [];

			// --------
			// We may hit a plain diff generated by old code.
			// Make sure we can deal with that.

			$diff = new Diff();

			$change = new ItemChange( [ 'type' => 'test' ] );
			$change->setDiff( $diff );

			$cases['plain-diff'] = [ $change ];

			// --------
			// Bug T53363: As of commit ff65735a125e, MapDiffer may generate atomic diffs for
			// substructures even in recursive mode. Make sure we can handle them
			// if we happen to load them from the database or such.

			$diff = new ItemDiff( [
				'links' => new DiffOpChange(
					[ 'foowiki' => 'X', 'barwiki' => 'Y' ],
					[ 'barwiki' => 'Y', 'foowiki' => 'X' ]
				)
			] );

			// make sure we got the right key for sitelinks
			assert( $diff->getSiteLinkDiff() !== null );

			//NOTE: ItemChange's constructor may or may not already fix the bad diff.
			$change = new ItemChange( [ 'type' => 'test' ] );
			$change->setDiff( $diff );

			$cases['atomic-sitelink-diff'] = [ $change ];
		} finally {
			$wgDevelopmentWarnings = true;
			\MediaWiki\restoreWarnings();
		}

		return $cases;
	}

	/**
	 * @dataProvider changeBackwardsCompatProvider
	 *
	 * @param ItemChange $change
	 * @throws Exception
	 */
	public function testGetSiteLinkDiffBackwardsCompat( ItemChange $change ) {
		//NOTE: Disable developer warnings that may get triggered by
		//      the B/C code path.
		$this->setMwGlobals( 'wgDevelopmentWarnings', false );

		// Also suppress notices that may be triggered by wfLogWarning
		\MediaWiki\suppressWarnings();

		try {
			$siteLinkDiff = $change->getSiteLinkDiff();
			$this->assertInstanceOf(
				Diff::class,
				$siteLinkDiff,
				'getSiteLinkDiff must return a Diff'
			);
		} finally {
			\MediaWiki\restoreWarnings();
		}
	}

}
